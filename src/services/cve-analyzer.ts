import { LlmService } from './llm-service';

export interface Vulnerability {
  type: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  lineNumber: number;
  description: string;
  cveId?: string | null;
  recommendation?: string;
}

export interface CveAnalysisResult {
  filePath: string;
  vulnerabilities: Vulnerability[];
  analysisTimestamp: string;
}

export class CveAnalyzer {
  constructor(private llmService: LlmService) {}

  async analyzeFile(filePath: string, fileContent: string): Promise<CveAnalysisResult> {
    try {
      // Use LLM to analyze the file for CVEs
      const llmResponse = await this.llmService.analyzeCves(filePath, fileContent);
      
      // Parse the LLM response
      let analysisData;
      try {
        // Extract JSON from response (in case there's extra text)
        const jsonMatch = llmResponse.match(/\{[\s\S]*\}/);
        const jsonContent = jsonMatch ? jsonMatch[0] : llmResponse;
        analysisData = JSON.parse(jsonContent);
      } catch (parseError) {
        // If parsing fails, create a fallback analysis
        analysisData = this.createFallbackAnalysis(llmResponse);
      }

      // Validate and sanitize the analysis data
      const vulnerabilities = this.validateVulnerabilities(analysisData.vulnerabilities || []);

      return {
        filePath,
        vulnerabilities,
        analysisTimestamp: new Date().toISOString(),
      };
    } catch (error) {
      console.warn(`Warning: Analysis failed for ${filePath}: ${error}`);
      return {
        filePath,
        vulnerabilities: [],
        analysisTimestamp: new Date().toISOString(),
      };
    }
  }

  private createFallbackAnalysis(llmResponse: string): any {
    // Basic pattern matching for common vulnerabilities when JSON parsing fails
    const vulnerabilities = [];
    
    if (llmResponse.toLowerCase().includes('sql injection')) {
      vulnerabilities.push({
        type: 'SQL Injection',
        severity: 'High',
        lineNumber: 1,
        description: 'Potential SQL injection vulnerability detected',
        recommendation: 'Use parameterized queries or prepared statements',
      });
    }

    if (llmResponse.toLowerCase().includes('xss') || llmResponse.toLowerCase().includes('cross-site scripting')) {
      vulnerabilities.push({
        type: 'Cross-Site Scripting (XSS)',
        severity: 'Medium',
        lineNumber: 1,
        description: 'Potential XSS vulnerability detected',
        recommendation: 'Sanitize user input and use output encoding',
      });
    }

    return { vulnerabilities };
  }

  private validateVulnerabilities(vulnerabilities: any[]): Vulnerability[] {
    return vulnerabilities
      .filter(vuln => vuln && typeof vuln === 'object')
      .map(vuln => ({
        type: vuln.type || 'Unknown Vulnerability',
        severity: this.validateSeverity(vuln.severity),
        lineNumber: typeof vuln.lineNumber === 'number' ? vuln.lineNumber : 1,
        description: vuln.description || 'No description provided',
        cveId: vuln.cveId || null,
        recommendation: vuln.recommendation || undefined,
      }));
  }

  private validateSeverity(severity: any): 'Critical' | 'High' | 'Medium' | 'Low' {
    const validSeverities = ['Critical', 'High', 'Medium', 'Low'];
    if (typeof severity === 'string' && validSeverities.includes(severity)) {
      return severity as 'Critical' | 'High' | 'Medium' | 'Low';
    }
    return 'Medium'; // Default fallback
  }

  // Additional static analysis patterns for common vulnerabilities
  performStaticAnalysis(filePath: string, fileContent: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const lines = fileContent.split('\n');

    lines.forEach((line, index) => {
      const lineNumber = index + 1;
      
      // Check for common vulnerability patterns
      if (this.checkSqlInjection(line)) {
        vulnerabilities.push({
          type: 'Potential SQL Injection',
          severity: 'High',
          lineNumber,
          description: 'Dynamic SQL query construction detected',
          recommendation: 'Use parameterized queries or ORM with proper escaping',
        });
      }

      if (this.checkHardcodedSecrets(line)) {
        vulnerabilities.push({
          type: 'Hardcoded Secrets',
          severity: 'Critical',
          lineNumber,
          description: 'Potential hardcoded secret or API key detected',
          recommendation: 'Move secrets to environment variables or secure key management',
        });
      }

      if (this.checkInsecureProtocol(line)) {
        vulnerabilities.push({
          type: 'Insecure Protocol',
          severity: 'Medium',
          lineNumber,
          description: 'HTTP protocol used instead of HTTPS',
          recommendation: 'Use HTTPS for all external communications',
        });
      }
    });

    return vulnerabilities;
  }

  private checkSqlInjection(line: string): boolean {
    const sqlPatterns = [
      /query.*\+.*["'`]/i,
      /execute.*\+.*["'`]/i,
      /["'`].*\+.*["'`].*sql/i,
    ];
    return sqlPatterns.some(pattern => pattern.test(line));
  }

  private checkHardcodedSecrets(line: string): boolean {
    const secretPatterns = [
      /(?:password|pwd|secret|key|token)\s*[:=]\s*["'`][^"'`\s]{8,}/i,
      /['"](sk|pk)_[a-zA-Z0-9]{20,}['"]/,
      /['"]\w{40,}['"]/,
    ];
    return secretPatterns.some(pattern => pattern.test(line));
  }

  private checkInsecureProtocol(line: string): boolean {
    return /http:\/\//.test(line) && !/localhost|127\.0\.0\.1/.test(line);
  }
} 