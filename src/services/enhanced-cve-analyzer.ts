import { LlmService } from './llm-service';
import { OwaspDependencyCheckService, OwaspDependencyCheckResult, OwaspVulnerability } from './owasp-dependency-check';

export interface EnhancedVulnerability {
  // OWASP fields
  cveId: string;
  name: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  cvssScore: number;
  description: string;
  references: string[];
  affectedArtifact: string;
  fileName: string;
  solution?: string;
  
  // LLM-enhanced fields
  llmAnalysis?: {
    riskAssessment: string;
    businessImpact: string;
    exploitabilityRating: 'High' | 'Medium' | 'Low';
    remediationPriority: 'Immediate' | 'High' | 'Medium' | 'Low';
    alternativeSolutions: string[];
    migrationComplexity: 'Simple' | 'Moderate' | 'Complex';
    estimatedEffort: string;
  };
  
  // Combined assessment
  finalRecommendation: string;
  actionRequired: boolean;
}

export interface EnhancedCveAnalysisResult {
  // OWASP scan results
  owaspResults: OwaspDependencyCheckResult;
  
  // Enhanced analysis
  enhancedVulnerabilities: EnhancedVulnerability[];
  
  // Risk assessment
  overallRiskLevel: 'Critical' | 'High' | 'Medium' | 'Low';
  immediateActionRequired: boolean;
  
  // Summary statistics
  summary: {
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    vulnerabilitiesNeedingImmediateAction: number;
  };
  
  // LLM insights
  strategicRecommendations: string[];
  migrationPlan?: {
    phases: Array<{
      phase: string;
      priority: number;
      estimatedDuration: string;
      activities: string[];
    }>;
    totalEstimatedDuration: string;
  };
  
  // Report metadata
  analysisTimestamp: string;
  reportPaths: {
    owaspHtmlReport?: string;
    owaspXmlReport?: string;
  };
}

export class EnhancedCveAnalyzer {
  private owaspService: OwaspDependencyCheckService;
  private llmService: LlmService;

  constructor(llmService: LlmService, nvdApiKey?: string) {
    this.llmService = llmService;
    this.owaspService = new OwaspDependencyCheckService(nvdApiKey);
  }

  async analyzeProject(projectPath: string): Promise<EnhancedCveAnalysisResult> {
    console.log('🚀 Starting enhanced CVE analysis with OWASP + LLM integration...');
    
    // Step 1: Run OWASP Dependency Check first
    console.log('📊 Step 1/3: Running OWASP Dependency Check with NVD data...');
    const owaspResults = await this.owaspService.runDependencyCheck(projectPath);
    
    if (!owaspResults.scanSuccess || owaspResults.vulnerabilities.length === 0) {
      console.log('ℹ️  No vulnerabilities found by OWASP scan or scan failed');
      return this.createEmptyResult(owaspResults);
    }

    // Step 2: Enhance vulnerabilities with LLM analysis
    console.log(`🧠 Step 2/3: Enhancing ${owaspResults.vulnerabilities.length} vulnerabilities with LLM analysis...`);
    const enhancedVulnerabilities = await this.enhanceVulnerabilitiesWithLLM(
      owaspResults.vulnerabilities,
      projectPath
    );

    // Step 3: Generate strategic recommendations
    console.log('📋 Step 3/3: Generating strategic recommendations and migration plan...');
    const strategicAnalysis = await this.generateStrategicRecommendations(
      enhancedVulnerabilities,
      owaspResults,
      projectPath
    );

    // Calculate summary statistics
    const summary = this.calculateSummary(enhancedVulnerabilities);
    const overallRiskLevel = this.determineOverallRisk(enhancedVulnerabilities);
    const immediateActionRequired = enhancedVulnerabilities.some(v => v.actionRequired);

    console.log(`✅ Enhanced CVE analysis complete! Found ${summary.totalVulnerabilities} vulnerabilities requiring analysis`);

    return {
      owaspResults,
      enhancedVulnerabilities,
      overallRiskLevel,
      immediateActionRequired,
      summary,
      strategicRecommendations: strategicAnalysis.recommendations,
      migrationPlan: strategicAnalysis.migrationPlan,
      analysisTimestamp: new Date().toISOString(),
      reportPaths: {
        owaspHtmlReport: owaspResults.reportPath,
        owaspXmlReport: owaspResults.xmlReportPath,
      },
    };
  }

  private async enhanceVulnerabilitiesWithLLM(
    owaspVulnerabilities: OwaspVulnerability[],
    projectPath: string
  ): Promise<EnhancedVulnerability[]> {
    const enhanced: EnhancedVulnerability[] = [];
    
    // Process vulnerabilities in batches to avoid overwhelming the LLM
    const batchSize = 5;
    for (let i = 0; i < owaspVulnerabilities.length; i += batchSize) {
      const batch = owaspVulnerabilities.slice(i, i + batchSize);
      
      try {
        const batchEnhanced = await this.enhanceVulnerabilityBatch(batch, projectPath);
        enhanced.push(...batchEnhanced);
      } catch (error) {
        console.warn(`Failed to enhance vulnerability batch ${i + 1}-${i + batch.length}:`, error);
        
        // Fallback: add vulnerabilities without LLM enhancement
        for (const vuln of batch) {
          enhanced.push(this.createFallbackEnhancedVulnerability(vuln));
        }
      }
    }
    
    return enhanced;
  }

  private async enhanceVulnerabilityBatch(
    vulnerabilities: OwaspVulnerability[],
    projectPath: string
  ): Promise<EnhancedVulnerability[]> {
    const prompt = this.buildVulnerabilityAnalysisPrompt(vulnerabilities, projectPath);
    
    const response = await this.llmService.sendRequest({
      prompt,
      maxTokens: 2000,
      temperature: 0.1,
    });

    try {
      // Parse LLM response
      const jsonMatch = response.content.match(/\{[\s\S]*\}/);
      const analysis = JSON.parse(jsonMatch ? jsonMatch[0] : response.content);
      
      return this.combineOwaspAndLlmData(vulnerabilities, analysis);
    } catch (error) {
      console.warn('Failed to parse LLM vulnerability analysis, using fallback');
      return vulnerabilities.map(v => this.createFallbackEnhancedVulnerability(v));
    }
  }

  private buildVulnerabilityAnalysisPrompt(vulnerabilities: OwaspVulnerability[], projectPath: string): string {
    const vulnSummaries = vulnerabilities.map(v => 
      `CVE: ${v.cveId}, Severity: ${v.severity}, CVSS: ${v.cvssScore}, Artifact: ${v.affectedArtifact}, Description: ${v.description.substring(0, 200)}...`
    ).join('\n');

    return `You are a cybersecurity expert analyzing vulnerabilities found by OWASP Dependency Check. 
Provide strategic analysis for each vulnerability in the context of application modernization.

Project: ${projectPath}
Vulnerabilities to analyze:
${vulnSummaries}

For each vulnerability, provide:
1. Risk assessment in business context
2. Business impact if exploited
3. Exploitability rating (High/Medium/Low)
4. Remediation priority (Immediate/High/Medium/Low)
5. Alternative solutions beyond simple version updates
6. Migration complexity (Simple/Moderate/Complex)
7. Estimated effort for remediation

Consider:
- Legacy application modernization context
- Spring Boot migration implications
- Cloud deployment considerations
- Team capability and timeline constraints

Format response as JSON:
{
  "vulnerabilityAnalyses": [
    {
      "cveId": "CVE-XXXX-XXXX",
      "riskAssessment": "string",
      "businessImpact": "string", 
      "exploitabilityRating": "High|Medium|Low",
      "remediationPriority": "Immediate|High|Medium|Low",
      "alternativeSolutions": ["string"],
      "migrationComplexity": "Simple|Moderate|Complex",
      "estimatedEffort": "string"
    }
  ]
}`;
  }

  private combineOwaspAndLlmData(
    owaspVulnerabilities: OwaspVulnerability[],
    llmAnalysis: any
  ): EnhancedVulnerability[] {
    const enhanced: EnhancedVulnerability[] = [];
    
    for (const owaspVuln of owaspVulnerabilities) {
      const llmData = llmAnalysis.vulnerabilityAnalyses?.find(
        (analysis: any) => analysis.cveId === owaspVuln.cveId
      );
      
      const enhancedVuln: EnhancedVulnerability = {
        ...owaspVuln,
        llmAnalysis: llmData ? {
          riskAssessment: llmData.riskAssessment || 'No assessment available',
          businessImpact: llmData.businessImpact || 'Impact assessment pending',
          exploitabilityRating: llmData.exploitabilityRating || 'Medium',
          remediationPriority: llmData.remediationPriority || 'Medium',
          alternativeSolutions: llmData.alternativeSolutions || [],
          migrationComplexity: llmData.migrationComplexity || 'Moderate',
          estimatedEffort: llmData.estimatedEffort || 'Assessment required',
        } : undefined,
        finalRecommendation: this.generateFinalRecommendation(owaspVuln, llmData),
        actionRequired: this.determineActionRequired(owaspVuln, llmData),
      };
      
      enhanced.push(enhancedVuln);
    }
    
    return enhanced;
  }

  private generateFinalRecommendation(owaspVuln: OwaspVulnerability, llmData?: any): string {
    const recommendations = [];
    
    if (owaspVuln.severity === 'Critical' || owaspVuln.cvssScore >= 9.0) {
      recommendations.push('🚨 CRITICAL: Address immediately');
    }
    
    if (llmData?.remediationPriority === 'Immediate') {
      recommendations.push('⚡ Immediate action required');
    }
    
    if (owaspVuln.solution) {
      recommendations.push(`Primary solution: ${owaspVuln.solution}`);
    }
    
    if (llmData?.alternativeSolutions?.length > 0) {
      recommendations.push(`Alternatives: ${llmData.alternativeSolutions.join(', ')}`);
    }
    
    return recommendations.join('. ') || 'Review and update dependency as needed';
  }

  private determineActionRequired(owaspVuln: OwaspVulnerability, llmData?: any): boolean {
    return (
      owaspVuln.severity === 'Critical' ||
      owaspVuln.cvssScore >= 7.0 ||
      llmData?.remediationPriority === 'Immediate' ||
      llmData?.exploitabilityRating === 'High'
    );
  }

  private async generateStrategicRecommendations(
    vulnerabilities: EnhancedVulnerability[],
    owaspResults: OwaspDependencyCheckResult,
    projectPath: string
  ): Promise<{ recommendations: string[], migrationPlan?: any }> {
    const prompt = `Based on the vulnerability analysis of ${vulnerabilities.length} security issues found in ${projectPath}, provide strategic recommendations for secure application modernization.

Project context:
- Total dependencies: ${owaspResults.projectInfo.dependencies}
- Vulnerable dependencies: ${owaspResults.projectInfo.vulnerableDependencies}
- Critical vulnerabilities: ${vulnerabilities.filter(v => v.severity === 'Critical').length}
- High severity: ${vulnerabilities.filter(v => v.severity === 'High').length}

Key vulnerabilities:
${vulnerabilities.slice(0, 10).map(v => `${v.cveId}: ${v.severity} (${v.affectedArtifact})`).join('\n')}

Provide:
1. Strategic recommendations for security improvement
2. Migration plan with phases, priorities, and timelines
3. Risk mitigation strategies
4. Technology stack modernization suggestions

Format as JSON:
{
  "recommendations": ["string"],
  "migrationPlan": {
    "phases": [
      {
        "phase": "string",
        "priority": number,
        "estimatedDuration": "string",
        "activities": ["string"]
      }
    ],
    "totalEstimatedDuration": "string"
  }
}`;

    try {
      const response = await this.llmService.sendRequest({
        prompt,
        maxTokens: 1500,
        temperature: 0.2,
      });

      const jsonMatch = response.content.match(/\{[\s\S]*\}/);
      return JSON.parse(jsonMatch ? jsonMatch[0] : response.content);
    } catch (error) {
      console.warn('Failed to generate strategic recommendations:', error);
      return {
        recommendations: [
          'Review and update all critical and high-severity vulnerabilities',
          'Implement automated dependency scanning in CI/CD pipeline',
          'Plan systematic modernization of legacy dependencies',
          'Consider containerization for better security isolation',
        ],
      };
    }
  }

  private createFallbackEnhancedVulnerability(owaspVuln: OwaspVulnerability): EnhancedVulnerability {
    return {
      ...owaspVuln,
      finalRecommendation: owaspVuln.solution || 'Update dependency to latest secure version',
      actionRequired: owaspVuln.severity === 'Critical' || owaspVuln.cvssScore >= 7.0,
    };
  }

  private createEmptyResult(owaspResults: OwaspDependencyCheckResult): EnhancedCveAnalysisResult {
    return {
      owaspResults,
      enhancedVulnerabilities: [],
      overallRiskLevel: 'Low',
      immediateActionRequired: false,
      summary: {
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        vulnerabilitiesNeedingImmediateAction: 0,
      },
      strategicRecommendations: ['No vulnerabilities detected', 'Continue monitoring dependencies'],
      analysisTimestamp: new Date().toISOString(),
      reportPaths: {
        owaspHtmlReport: owaspResults.reportPath,
        owaspXmlReport: owaspResults.xmlReportPath,
      },
    };
  }

  private calculateSummary(vulnerabilities: EnhancedVulnerability[]) {
    return {
      totalVulnerabilities: vulnerabilities.length,
      criticalCount: vulnerabilities.filter(v => v.severity === 'Critical').length,
      highCount: vulnerabilities.filter(v => v.severity === 'High').length,
      mediumCount: vulnerabilities.filter(v => v.severity === 'Medium').length,
      lowCount: vulnerabilities.filter(v => v.severity === 'Low').length,
      vulnerabilitiesNeedingImmediateAction: vulnerabilities.filter(v => v.actionRequired).length,
    };
  }

  private determineOverallRisk(vulnerabilities: EnhancedVulnerability[]): 'Critical' | 'High' | 'Medium' | 'Low' {
    if (vulnerabilities.some(v => v.severity === 'Critical')) return 'Critical';
    if (vulnerabilities.filter(v => v.severity === 'High').length > 2) return 'High';
    if (vulnerabilities.some(v => v.severity === 'High')) return 'High';
    if (vulnerabilities.some(v => v.severity === 'Medium')) return 'Medium';
    return 'Low';
  }
} 